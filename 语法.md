1.
```
public DocumentationType(String name, String version) {
    this(name, version, MediaType.APPLICATION_JSON);
}
```
this(name, version, MediaType.APPLICATION_JSON)：这是一个对同一个类中另一个构造函数的调用，这通常被称为构造函数重载。在这里，this 关键字用于调用接受三个参数的构造函数，其中前两个参数是传递给当前构造函数的 name 和 version，第三个参数是 MediaType.APPLICATION_JSON，这是一个预设的常量值，表示默认的媒体类型是 JSON

2.
```
log.info("新增员工：{}", employeeDTO);
```
{} 是占位符;

3. BeanUtils 
```
BeanUtils.copyProperties(employeeDTO, employee);    // 属性拷贝, 注意方法，前者为 拷贝目标， 后者为 拷贝对象， 必须要求属性名要一致
```

4. SQLIntegrityConstraintViolationException
```
1.主键约束违反：当试图插入一个已经存在于表中的主键值时。
2.外键约束违反：当试图插入或更新一个外键值，而这个值在相关联的表中不存在时。
3.唯一性约束违反：当试图插入一个已经在表中具有唯一性约束的字段中存在的值时。
4.检查约束违反：当插入或更新的数据不满足表上的检查约束条件时
```

5. 改变日期格式
方法1：在属性上加注解，对日期进行格式化 
```
@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
private LocalDateTime updateTime;
```
方法2：在 WebMvcConfiguration 中扩展 Spring MVC的消息转换器，同一对日期类型进行格式化处理


6. 公共字段自动填充
自定义注解 AutoFill, 标识需要进行公共字段自动填充的方法
自定义切面类 AutoFillAspect, 统一拦截加入 AutoFill 注解的方法，通过反射为公共字段赋值
在 Mapper 方法上加入 AutoFill 注解

7. JAVA 反射
它允许在运行时检查或修改程序，允许程序在运行时访问对象的内部属性，包括类名、方法、构造函数、注解等

8. 在新增 和 修改 时属性拷贝的必要性：
  1.数据传输对象（DTO）与领域对象分离，在业务逻辑中，我们会定义一个数据传输对象（DTO），它只包含与业务逻辑相关的数据,领域对象（DO）则包含更详细的数据和业务逻辑,当我们需要将DTO的数据传递给DO时，就需要进行属性拷贝
  2.避免直接操作数据库，需要通过一个DTO对象来操作数据库，而不是直接操作DO
  3.解耦合：可以将不同的业务逻辑模块解耦，一个服务层负责处理业务逻辑，它只与DTO交互，而将DO的创建和操作交给DAO层
  4.性能优化: 领域对象可能包含大量的数据和业务逻辑,通过属性拷贝，我们可以创建一个轻量级的DTO，只包含与当前业务操作相关的数据，从而提高性能
  5.方便测试： 可以使用DTO来模拟业务数据，而不需要创建完整的DO

9. 先插入菜品，
```
dishMapper.insert(dish);
// 获取 insert 语句生成的主键
Long dishId = dish.getId();

```
菜品 xml 
```
# useGeneratedKeys="true"：这是一个属性，指示MyBatis在执行插入操作后，应该获取数据库生成的键值（如自增ID）。如果设置为 true，MyBatis会自动将生成的键值设置到Java对象对应的属性上
# keyProperty="id"：这是另一个属性，指定了Java对象中应该设置生成的键值的属性名。这个属性名必须与数据库表中的主键字段名对应
<insert id="insert" useGeneratedKeys="true" keyProperty="id">
        insert into dish(name, category_id, price, image, description, create_time, update_time, create_user, update_user, status)
            values
        (#{name}, #{categoryId}, #{price}, #{iamge}, #{description}, #{createTime}, #{updateTime}, #{createUser}, #{updateUser}, #{status})
</insert>
```
在插入并获得菜品 id 后，给每个 口味赋值 id 并 将口味数据插入
```
// 向口味插入n条数据
List<DishFlavor> flavors = dishDTO.getFlavors();
if( flavors != null && flavors.size() > 0) {
    flavors.forEach(dishFlavor -> {
        dishFlavor.setDishId(dishId);
    });
    // 将集合整体插入
    dishFlavorMapper.batchInsert(flavors);
}
```
口味 xml
```
<insert id="batchInsert">
        insert into dish_flavor (dish_id, name, values) VALUES
        <foreach collection="flavors" item="df" separator=",">
            (#{df.dishId}, #{df.name}, #{df.value})
        </foreach>
</insert>
```

10.MappingJackson2CborHttpMessageConverter 和 MappingJackson2HttpMessageConverter 的区别
MappingJackson2CborHttpMessageConverter 和 MappingJackson2HttpMessageConverter 都是Spring框架中用于处理HTTP请求和响应的HttpMessageConverter实现，但它们处理的数据格式不同:
10.1 MappingJackson2HttpMessageConverter:处理JSON格式的数据
10.2 MappingJackson2CborHttpMessageConverter: 处理CBOR（Concise Binary Object Representation）格式的数据


11. DTO和VO
DTO（Data Transfer Object）:是一种设计模式，用于在不同的进程或网络之间传输数据,简单的传输类，用来封装数据,常用于分布式系统中的服务之间传递数据, DTO通常会是贫血模型，即只有数据字段和getter/setter方法，没有业务逻辑
VO（Value Object）:是一种设计模式，它代表一个对象，其包含的数据具有内在的逻辑意义，但通常不包含标识信息,包含一些简单的业务逻辑,侧重于在单个应用或模块内部使用

DTO通常用于数据在不同层之间传输，例如从数据访问层传递到业务逻辑层，或者从服务层传递到表示层；DTO 是前端传给后端用的;
VO则更常用于表示层，用来展示数据给用户，或者作为业务逻辑层的操作对象； VO 是后端响应给前端用的，

12. 批量删除
```
<!--相当于 delete from dish where id in (...)-->
<delete id="deleteByIds">
    delete from dish where id in
    <foreach collection="ids" item="id" open="(" close=")">
        #{id}
    </foreach>
</delete>
```

13. 若在不同的文件目录下使用相同的 bean 名，会报错 bean 命名冲突，解决办法：
@RestController("/xxx")
@RestController("/yyy")
在 @RestController 中添加不同的 name

14. BigDecimal 类被广泛用于高精度的浮点数运算 new BigDecimal(0.01): 输出一个精确的0.01

15. JSON 的各种用法
```
// 1. 序列化 Java 对象到 JSON 字符串;对象转化为 String
User user = new User("张三", 30);
String jsonString = JSON.toJSONString(user);

// 2. 反序列化 JSON 字符串到 Java 对象; 字符串转化为对象
String jsonString = "{\"name\":\"李四\",\"age\":25}";
User user = JSON.parseObject(jsonString, User.class);

// 3. 嵌套对象和集合
String jsonString = "{\"name\":\"张三\",\"age\":30,\"children\":[{\"name\":\"张一一\",\"age\":10},{\"name\":\"张二二\",\"age\":15}]}";
Family family = JSON.parseObject(jsonString, Family.class);

// 4. 自定义序列化和反序列化
User user = new User("张三", 30);
String jsonString = JSON.toJSONString(user, SerializerFeature.PrettyFormat);

User user2 = JSON.parseObject(jsonString, User.class);

// 5. 处理 JSON 数组
String jsonArrayString = "[{\"name\":\"张三\",\"age\":30},{\"name\":\"李四\",\"age\":25}]";
List<User> users = JSON.parseArray(jsonArrayString
```

16. long total = Optional.ofNullable(pageOrders).map(Page::getTotal).orElse(0L);
// Optional.ofNullable(pageOrders)：这个方法会创建一个Optional对象。如果pageOrders是非null的，它会返回一个包含pageOrders的Optional对象；如果pageOrders是null，它会返回一个空的Optional对象
// .map(Page::getTotal)：如果Optional对象中包含一个值，这个方法会应用Page::getTotal这个方法引用（假设Page类有一个getTotal()方法），并返回一个新的Optional对象
// .map() 方法，该方法接受一个函数作为参数。如果 Optional 对象包含一个值，这个函数就会应用到该值上，并且返回一个新的 Optional 对象，其中包含应用函数后的结果。如果 Optional 对象为空，则不会执行函数，.map() 方法会直接返回一个空的 Optional 对象
// Page::getTotal 是 page -> page.getTotal()
// .orElse(0L) Optional对象中有值，它会返回这个值；如果Optional对象为空，它会返回默认值0L

17. Stream
    .collect(Collectors.toList());  // 返回一个不可修改的 List
    你需要可修改的 List，可以显式地指定为 Collectors.toCollection(LinkedList::new) 或其他任何集合类型

18. mybatis <foreach>
```
<select id="selectCartsByUserIds" resultType="ShoppingCart">
    SELECT * FROM shopping_cart
    WHERE user_id IN
    <foreach item="userId" collection="userIds" open="(" separator="," close=")">
        #{userId}
    </foreach>
</select>

id 属性定义了 MyBatis 映射的唯一标识符。
resultType 属性指定了返回结果的类型。
WHERE user_id IN 是 SQL 语句的一部分，用于指定查询条件。
<foreach> 标签用于迭代 userIds 集合。
item 属性定义了集合中每个元素的别名（在这个例子中是 userId）。
collection 属性指定了要迭代的集合（在这个例子中是 userIds）。
open 属性定义了 <foreach> 循环开始时应该插入的字符串（在这个例子中是左括号 (）。
separator 属性定义了集合中每个元素之间的分隔符（在这个例子中是逗号 ,）。
close 属性定义了 <foreach> 循环结束时应该插入的字符串（在这个例子中是右括号 )）。
#{userId} 是 MyBatis 的参数占位符，用于防止 SQL 注入。

假设 userIds 是一个包含多个用户 ID 的集合，例如 {1, 2, 3}，生成的 SQL 语句将类似于：
SELECT * FROM shopping_cart WHERE user_id IN (1, 2, 3)
```
